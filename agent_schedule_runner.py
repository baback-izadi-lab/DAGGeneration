import json
import random
"""
This module runs and calculates execution times for each task and processor
 based on the schedule generated by EDLS.py
"""


class Task:
    def __init__(self, task_num, processor, speed,
                 exec_time, exec_power, comm_data,
                 speed_data, power_data, beta=1.0,
                 agent_system=True):
        self.task_num = task_num
        self.processor = processor
        self.speed = speed
        self.clock_time = 0
        self.slack_time = 0
        self.exec_time = exec_time
        self.exec_power = exec_power
        self.comm_data = comm_data
        self.task_complete = False
        self.speed_data = speed_data
        self.power_data = power_data
        self.beta = beta
        self.agent_system = agent_system

    def set_graphs(self, parents, children, processor_times):
        self.parents = parents
        self.children = children
        self.processor_times = processor_times

    def message(self, task, clock_time, slack=0):
        if task in self.parents:
            if clock_time > self.clock_time:
                self.clock_time = clock_time
                self.slack_time = slack
            self.parents.remove(task)

        # All parents of this task are finished and
        # This task is still incomplete, then start execution
        if len(self.parents) == 0 and not self.task_complete:
            self.avail_time = self.slack_time + self.exec_time
            # Agent logic
            if self.agent_system:
                for speed, exec_time in enumerate(self.speed_data):
                    if exec_time <= self.avail_time:
                        self.speed = speed
                        self.exec_time = exec_time
                        self.exec_power = self.power_data[speed]

            self.actual_exec = self.exec_time * self.beta
            self.start_time = self.clock_time
            self.clock_time += self.actual_exec

            self.end_time = self.start_time + self.actual_exec
            """
            print('Task {}: '
                  'Proc: {} '
                  'Speed: {} '
                  'Exec Time = {:.3f}-{:.3f} '
                  'Slack Time = {:.3f}'.format(self.task_num,
                                               self.processor,
                                               self.speed,
                                               self.start_time,
                                               self.end_time,
                                               self.avail_time - self.actual_exec))
            """
            energy = self.actual_exec * self.exec_power
            task_stats = (self.task_num, round(self.start_time, 3),
                          round(self.end_time, 3), round(energy, 3))
            self.processor_times[self.processor].append(task_stats)
            for child in self.children:
                if child.processor == self.processor:

                    child.message(self.task_num, self.clock_time,
                                  self.avail_time-self.actual_exec)
                else:
                    child.message(self.task_num, self.clock_time +
                                  self.comm_data[(
                                      self.task_num, child.task_num)],
                                  self.avail_time-self.actual_exec)
            self.task_complete = True


class ScheduleRunner:
    def __init__(self, schedule='agent_schedule.json',
                 dag_data='test_simple.json',
                 speed_setting=[],
                 base_powers=None, beta=1.0,
                 agent_system=True):

        self.beta = beta
        self.speed_setting = speed_setting
        self.base_powers = base_powers
        self.dag_data = json.load(open(dag_data))
        self.schedule = json.load(open(schedule))
        # Keep track of all task objects
        self.all_tasks = {}
        # Keep track of communication data
        self.comm_data = {}
        for data in self.dag_data['arcs'].values():
            self.comm_data[(data[0], data[1])] = data[2]

        # Start creating tasks
        for task_detail in self.schedule:
            task = int(task_detail)
            processor = self.schedule[task_detail]['processor']
            speed = self.schedule[task_detail]['speed']
            exec_time = self.dag_data['proc_exec'][str(processor)][speed][task]
            exec_power = self.dag_data['proc_power'][str(
                processor)][speed][task]
            all_exec = self.dag_data['proc_exec'][str(processor)]
            all_power = self.dag_data['proc_power'][str(processor)]
            speed_data = [all_exec[speed][task]
                          for speed in range(len(all_exec))]
            power_data = [all_power[speed][task]
                          for speed in range(len(all_power))]

            # Deciding beta values for task
            if isinstance(self.beta, float):
                task_beta = self.beta
            elif isinstance(self.beta, list):
                task_beta = self.beta[task]
            t = Task(task, processor, speed, exec_time,
                     exec_power, self.comm_data, speed_data, power_data,
                     task_beta,
                     agent_system=agent_system)
            self.all_tasks[task] = t

        # Task setup connecting parents and children
        self.processor_times = [[]
                                for i in range(len(self.dag_data['proc_exec']))]
        for task_num, task in self.all_tasks.items():
            parents = set(self.schedule[str(task_num)]['parents'])
            children = set()
            for child_num in self.schedule[str(task_num)]['children']:
                children.add(self.all_tasks[child_num])
            task.set_graphs(parents, children, self.processor_times)

    def start(self):
        for task in self.all_tasks.values():
            if len(task.parents) == 0:
                task.message(None, 0)

    @property
    def task_energy(self):
        return sum([task[3] for proc in self.processor_times for task in proc])

    @property
    def max_time(self):
        return max([task[2] for proc in self.processor_times for task in proc])

    @property
    def idle_times(self):
        all_idle_times = []
        max_time = self.max_time
        for proc_num, proc in enumerate(self.processor_times):
            proc_idle = max_time
            for task in proc:
                proc_idle -= task[2]-task[1]
            if self.speed_setting[proc_num] is None:
                all_idle_times.append(0)
            else:
                all_idle_times.append(proc_idle)

        return all_idle_times

    @property
    def idle_energy(self):
        idle_energy = 0
        for proc_num, time in enumerate(self.idle_times):
            lowest_power = self.base_powers[proc_num] * 0.4
            idle_energy += lowest_power * time
        return idle_energy


if __name__ == "__main__":
    base_powers = [5, 15, 25]
    runner = ScheduleRunner(schedule='./results/EDLS/DAG-10/agent_schedule.json',
                            dag_data='./results/EDLS/DAG-10/task_data.json',
                            speed_setting=[None, None, 2],
                            base_powers=base_powers,
                            agent_system=True)

    runner.start()
    print(runner.processor_times)

    print(runner.task_energy)

    print(runner.max_time)

    print(runner.idle_times)
    print(runner.idle_energy)
    print('Total Energy: {}'.format(runner.task_energy + runner.idle_energy))
    #import plot

    #plot.plot(runner.processor_times, runner.max_time)
