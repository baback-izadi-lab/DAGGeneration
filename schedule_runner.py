import json
"""
This module runs and calculates execution times for each task and processor
 based on the schedule generated by EDLS.py
"""


class Task:
    def __init__(self, task_num, processor, speed,
                 exec_time, exec_power, comm_data):
        self.task_num = task_num
        self.processor = processor
        self.speed = speed
        self.clock_time = 0
        self.exec_time = exec_time
        self.exec_power = exec_power
        self.comm_data = comm_data
        self.task_complete = False

    def set_graphs(self, parents, children, processor_times):
        self.parents = parents
        self.children = children
        self.processor_times = processor_times

    def message(self, task, clock_time):
        if task in self.parents:
            if clock_time > self.clock_time:
                self.clock_time = clock_time
            self.parents.remove(task)
        if len(self.parents) == 0 and not self.task_complete:
            self.start_time = self.clock_time
            self.clock_time += self.exec_time
            self.end_time = self.start_time + self.exec_time
            print('Task {}: Proc: {} Exec Time = {:.3f}-{:.3f}'.format(self.task_num,
                                                                       self.processor,
                                                                       self.start_time,
                                                                       self.end_time))
            energy = self.exec_time * self.exec_power
            task_stats = (self.task_num, round(self.start_time, 3),
                          round(self.end_time, 3), round(energy, 3))
            self.processor_times[self.processor].append(task_stats)
            for child in self.children:
                if child.processor == self.processor:

                    child.message(self.task_num, self.clock_time)
                else:
                    child.message(self.task_num, self.clock_time +
                                  self.comm_data[(self.task_num, child.task_num)])
            self.task_complete = True


class ScheduleRunner:
    def __init__(self, schedule='agent_schedule.json',
                 dag_data='test_simple.json',
                 base_powers=None):
        self.base_powers = base_powers
        self.dag_data = json.load(open(dag_data))
        self.schedule = json.load(open(schedule))
        # Keep track of all task objects
        self.all_tasks = {}
        # Keep track of communication data
        self.comm_data = {}
        for data in self.dag_data['arcs'].values():
            self.comm_data[(data[0], data[1])] = data[2]

        # Start creating tasks
        for task_detail in self.schedule:
            task = int(task_detail)
            processor = self.schedule[task_detail]['processor']
            speed = self.schedule[task_detail]['speed']
            exec_time = self.dag_data['proc_exec'][str(processor)][speed][task]
            exec_power = self.dag_data['proc_power'][str(
                processor)][speed][task]
            t = Task(task, processor, speed, exec_time,
                     exec_power, self.comm_data)
            self.all_tasks[task] = t

        # Task setup connecting parents and children
        self.processor_times = [[]
                                for i in range(len(self.dag_data['proc_exec']))]
        for task_num, task in self.all_tasks.items():
            parents = set(self.schedule[str(task_num)]['parents'])
            children = set()
            for child_num in self.schedule[str(task_num)]['children']:
                children.add(self.all_tasks[child_num])
            task.set_graphs(parents, children, self.processor_times)

    def start(self):
        for task in self.all_tasks.values():
            if len(task.parents) == 0:
                task.message(None, 0)

    @property
    def task_energy(self):
        return sum([task[3] for proc in self.processor_times for task in proc])

    @property
    def max_time(self):
        return max([task[2] for proc in self.processor_times for task in proc])

    @property
    def idle_times(self):
        all_idle_times = []
        max_time = self.max_time
        for proc in self.processor_times:
            proc_idle = max_time
            for task in proc:
                proc_idle -= task[2]-task[1]
            all_idle_times.append(proc_idle)
        return all_idle_times

    @property
    def idle_energy(self):
        idle_energy = 0
        for proc_num, time in enumerate(self.idle_times):
            lowest_power = self.base_powers[proc_num] * 0.4
            idle_energy += lowest_power * time
        return idle_energy


if __name__ == "__main__":
    base_powers = [5, 5, 5]
    runner = ScheduleRunner(base_powers=base_powers)
    runner.start()
    print(runner.processor_times)

    print(runner.task_energy)

    print(runner.max_time)

    print(runner.idle_times)
    print(runner.idle_energy)
    print('Total Energy: {}'.format(runner.task_energy + runner.idle_energy))
    import plot

    plot.plot(runner.processor_times, runner.max_time)
